<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SIMOC Sensor Dashboard</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <style>
        @font-face {
            font-family: 'NasalizationRg';
            src: url('/static/fonts/nasalization-rg-webfont.woff') format('woff');
            font-weight: normal;
            font-style: normal;
            font-display: swap;   /* ← shows fallback font immediately while loading */
        }
        body { 
            background: url('/static/BKG.png') no-repeat center center fixed; 
            background-size: cover; 
            color: orange; 
            margin: 0; padding: 0; position: relative;
        }
        #main .row:first-child ~ * {
                display: none !important;
            }
        body::before {
            content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.15); z-index: -1;
        }
        .top-bar { 
            background-color: rgba(0, 0, 0, 0.8); padding: 15px 20px; display: flex; align-items: center; 
            backdrop-filter: blur(5px);
        }
        
        .top-bar img { height: 60px; margin-right: 20px; }
        .top-bar span { color: rgb(255, 255, 255); font-size: 32px; font-weight: bold; font-family: 'NasalizationRg', Arial, Helvetica, sans-serif;  /* fallback */}
        .nav-tabs { background-color: rgba(0, 0, 0, 0.7); border: none; backdrop-filter: blur(5px); }
        .nav-tabs .nav-link { color: rgb(255, 255, 255); border: none; }
        .nav-tabs .nav-link.active { color: rgb(255, 255, 255); background: transparent; border-bottom: 3px solid orange; }
        .chart-container { 
            position: relative; height: 320px; margin: 20px 0; 
            background: rgba(0, 0, 0, 0.5); border-radius: 10px; padding: 10px;
        }
        .spinner { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            border: 8px solid #f3f3f3; border-top: 8px solid orange; border-radius: 50%;
            width: 60px; height: 60px; animation: spin 1s linear infinite; 
        }
        @keyframes spin { 0% { transform: translate(-50%, -50%) rotate(0deg); } 100% { transform: translate(-50%, -50%) rotate(360deg); } }
        .loading-text { text-align: center; margin-top: 20px; font-size: 18px; color: orange; }
        h2, h4 { color: white; }
        label { color: orange; }
        .btn-warning { background-color: orange; border-color: orange; color: black; }
        .btn-secondary {background-color: orange; border-color: orange; color: black;}
        .btn-warning:hover { background-color: #ffaa00; border-color: #ffaa00; }
        .btn-info { background-color: #17a2b8; border-color: #17a2b8; }
        hr { border-color: rgba(255,165,0,0.3); margin: 60px 0; }

    </style>
</head>
<body>
    <div class="top-bar">
        <div style="display: flex; align-items: center;">
            <img src="/static/logo.png" alt="Logo">
            <span>SIMOC Live</span>
        </div>
        <div style="flex: 1;"></div> <!-- spacer - no toggle anymore -->
        <ul class="nav nav-tabs justify-content-center" id="myTab" role="tablist, style="margin-left: 40px;">
            <li class="nav-item"><button class="nav-link active" id="main-tab" data-bs-toggle="tab" data-bs-target="#main">Main</button></li>
            {% for sensor in sensors %}
                <li class="nav-item"><button class="nav-link" id="{{ sensor }}-tab" data-bs-toggle="tab" data-bs-target="#{{ sensor }}">{{ sensor }}</button></li>
            {% endfor %}
        </ul>

        <div style="flex: 1;"></div> <!-- spacer - no toggle anymore -->

    </div>

    <div class="container mt-4">
        
        <div class="tab-content" id="myTabContent">
            <!-- MAIN TAB (Live + Overview) -->
            <div class="tab-pane fade show active" id="main" role="tabpanel">
                <div class="row">
                    {% for sensor in sensors %}
                        <div class="{{ live_col_class }}">
                            <!-- <h4 class="text-center">{{ sensor }}</h4> -->
                            <div id="{{ sensor }}-live-loading" class="chart-container" style="position: relative;">
                                <div class="spinner"></div>
                                <div class="loading-text">Loading live data...</div>
                            </div>
                            <div class="chart-container" style="display:none; padding-top: 15px;" id="{{ sensor }}-live-container">
                                <canvas id="{{ sensor }}-live-chart"></canvas>
                            </div>
                        </div>
                    {% endfor %}
                </div>
                <h2 class="text-center mb-4 mt-4"> <i>Live View - 2 Hrs</i></h2>
                <hr class="my-5">

                <h2 class="text-center mb-4">Full History - Overview</h2>
                <div class="row" >
                    {% for sensor in sensors %}
                        <div class="col-lg-6 col-md-6 col-sm-12">
                            <h4 class="text-center">{{ sensor }} - Full Dataset</h4>
                            <div id="{{ sensor }}-total-loading" class="chart-container" style="position: relative;">
                                <div class="spinner"></div>
                                <div class="loading-text">Loading history...</div>
                            </div>
                            <div class="chart-container" style="display:none;" id="{{ sensor }}-total-container">
                                <canvas id="{{ sensor }}-total-chart"></canvas>
                            </div>
                        </div>
                    {% endfor %}
                </div>
            </div>

            <!-- PER-SENSOR DETAILED TABS -->
            {% for sensor, info in sensors.items() %}
                <div class="tab-pane fade" id="{{ sensor }}" role="tabpanel">
                    <h2 class="mb-4">{{ sensor }} - Interactive Data View</h2>

                    <!-- CONTROLS -->
                    <div class="mb-4 d-flex justify-content-between align-items-center">
                        <div>
                            
                            <button onclick="resetToLast2h('{{ sensor }}')" class="btn btn-secondary me-2">Last 2 Hours</button>
                            <button onclick="resetToLast24h('{{ sensor }}')" class="btn btn-secondary me-2">Last 24 Hours</button>
                            <button onclick="resetToFullData('{{ sensor }}')" class="btn btn-secondary me-2">Full Data</button>
                            <button onclick="downloadInputRange('{{ sensor }}')" class="btn btn-info">Download CSV</button>
                        </div>
                      
                        <!-- <div class="form-group d-inline-block ms-3">
                            <label class="form-label me-2" style="color: orange;">Missing handling:</label>
                            <select id="{{ sensor }}-missing-mode" class="form-select d-inline-block" style="width: 160px;">
                                <option value="interpolate" selected>Interpolate (smooth)</option>
                                <option value="clip0">Clip to zero</option>
                                <option value="discrete">Discrete (no connect)</option>
                            </select>
                        </div> -->

                    </div>

                    <!-- INPUT SECTION: Controls & Parameters -->
                    <div class="row mb-3 align-items-end">
                        <div class="col-md-2">
                            <label class="form-label">Parameter</label>
                            <select id="{{ sensor }}-metric" class="form-select">
                                {% for p in info.params %}
                                    <option value="{{ p }}">{{ p }}</option>
                                {% endfor %}
                            </select>
                        </div>
                        <div class="col-md-2">
                            <label class="form-label">Start Date</label>
                            <input type="date" id="{{ sensor }}-start-date" class="form-control">
                        </div>
                        <div class="col-md-2">
                            <label class="form-label">Start Time</label>
                            <input type="time" id="{{ sensor }}-start-time" class="form-control" step="60">
                        </div>
                        <div class="col-md-2">
                            <label class="form-label">End Date</label>
                            <input type="date" id="{{ sensor }}-end-date" class="form-control">
                        </div>
                        <div class="col-md-2">
                            <label class="form-label">End Time</label>
                            <input type="time" id="{{ sensor }}-end-time" class="form-control" step="60">
                        </div>
                        <div class="col-md-2">
                            <button onclick="loadCustomRangeData('{{ sensor }}')" class="btn btn-warning me-2">Refresh</button>
                        </div>
                        
                    </div>
                  


                    <!-- OUTPUT SECTION: Chart -->
                    <div id="{{ sensor }}-detailed-loading" class="chart-container mt-4" style="position: relative;">
                        <div class="spinner"></div>
                        <div class="loading-text">Loading data...</div>
                    </div>
                    <div class="chart-container mt-4" style="display:none;" id="{{ sensor }}-detailed-container">
                        <canvas id="{{ sensor }}-detailed-chart"></canvas>
                    </div>
                </div>
            {% endfor %}
        </div>
    </div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script>
    const sensors = {{ sensors|tojson }};
    let charts = {};
    let fullSensorData = {};  // Will store { sensor: [full decimated entries] }
    // ─────────────────────────────────────────────────────────────
    // 1. CHART INITIALIZATION FUNCTIONS
    // ─────────────────────────────────────────────────────────────

    function initLiveChart(canvasId, data, sensorName) {
        const params = sensors[sensorName].params;
        const colors = sensors[sensorName].colors;

        // Capitalize first letter properly
        const capitalize = str => {
            if (!str) return '';
            return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
        };
        const labelFix = (p) => {
                if (p === 'linear_accel_x') return 'AccX';
                if (p === 'linear_accel_y') return 'AccY';
                if (p === 'linear_accel_z') return 'AccZ';
                return capitalize(p);
            };
        const datasets = params.map((p, i) => ({
            //label: capitalize(p),                    // e.g. Co2, Temperature, Humidity
            label: labelFix(p),
            data: data.map(d => ({ x: d.timestamp, y: d[p] || null })),
            borderColor: colors[i],
            backgroundColor: colors[i] + '40',
            tension: 0.3,
            pointRadius: 0,
            fill: false,
            borderWidth: 2.5,                        // nice visible thickness
            borderDash: [0]                          // SOLID lines only - no dashes
        }));

        return new Chart(document.getElementById(canvasId), {
            type: 'line',
            data: { datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,

                plugins: {
                    title: {
                        display: true,
                        text: sensorName.toUpperCase(),      // ← ALL UPPERCASE like "SCD-30"
                        color: 'white',
                        font: {
                            size: 22,
                            weight: 'bold',
                            family: "'NasalizationRg'"
                        },
                        align: 'center',                     // ← CENTERED at top
                        padding: {
                            top: 5,
                            bottom: 10
                        }
                    },

                    legend: {
                        position: 'bottom',
                        align: 'center',
                        labels: {
                            color: 'white',
                            font: {
                                size: 13,
                                family: "sans-serif"  // optional: also legend in Nasalization
                            },
                            padding: 18,
                            usePointStyle: true,             // ← this is key for nice line samples
                            pointStyle: 'line',              // force line instead of circle/box
                            boxWidth: 120,                    // longer line sample
                            boxHeight: 8,                    // thin line
                            lineWidth: 8,
                            useBorderRadius: false,
                            borderRadius: 0
                        }
                    },

                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        titleColor: 'orange',
                        bodyColor: 'white',
                        borderColor: 'orange',
                        borderWidth: 1,
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) label += ': ';
                                if (context.parsed.y !== null) {
                                    label += context.parsed.y.toFixed(2);
                                }
                                return label;
                            }
                        }
                    }
                },

                interaction: {
                    mode: 'index',
                    intersect: false
                },

                scales: {
                    x: {
                        type: 'time',
                        time: { unit: 'minute', displayFormats: { minute: 'HH:mm' } },
                        grid: { color: 'rgba(255,255,255,0.2)' },
                        ticks: { color: 'white' }
                    },
                    y: {
                        grid: { color: 'rgba(255,255,255,0.2)' },
                        ticks: { color: 'white' }
                    }
                }
            }
        });
    }

    function initDecimatedChart(canvasId, data, sensorName) {
        const params = sensors[sensorName].params;
        const colors = sensors[sensorName].colors;
        const labels = data.map(d => d.timestamp);
        const datasets = params.map((p, i) => ({
            label: p,
            data: data.map(d => d[p] || null),
            borderColor: colors[i],
            tension: 0.2,
            pointRadius: 0,
            fill: false
        }));

        return new Chart(document.getElementById(canvasId), {
            type: 'line',
            data: { labels, datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                plugins: {
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        titleColor: 'orange',
                        bodyColor: 'white',
                        borderColor: 'orange',
                        borderWidth: 1,
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) label += ': ';
                                if (context.parsed.y !== null) {
                                    label += context.parsed.y.toFixed(2);
                                }
                                return label;
                            }
                        }
                    },
                    legend: { labels: { color: 'orange' } }
                },
                scales: {
                    x: {
                        ticks: {
                            color: 'orange',
                            maxTicksLimit: 20,
                            callback: function(value, index) {
                                if (labels.length === 0) return '';
                                const date = new Date(labels[index]);
                                const prevDate = index > 0 ? new Date(labels[index-1]) : null;
                                if (index === 0 || (prevDate && date.getDate() !== prevDate.getDate())) {
                                    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                                }
                                if (date.getHours() % 6 === 0 && (!prevDate || date.getHours() !== prevDate.getHours())) {
                                    return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                                }
                                return '';
                            }
                        },
                        grid: { color: 'rgba(255,255,255,0.2)' }
                    },
                    y: {
                        grid: { color: 'rgba(255,255,255,0.2)' },
                        ticks: { color: 'orange' }
                    }
                }
            }
        });
    }

    // ─────────────────────────────────────────────────────────────
    // 2. MAIN DASHBOARD LOADING & LIVE UPDATES
    // ─────────────────────────────────────────────────────────────

    function loadMainData(sensor) {
        document.getElementById(`${sensor}-live-loading`).style.display = 'block';
        document.getElementById(`${sensor}-live-container`).style.display = 'none';
        fetch(`/last_2h_data/${sensor}`)
            .then(r => r.json())
            .then(data => {
                charts[`${sensor}-live`] = initLiveChart(`${sensor}-live-chart`, data, sensor);
                document.getElementById(`${sensor}-live-loading`).style.display = 'none';
                document.getElementById(`${sensor}-live-container`).style.display = 'block';
            })
            .catch(err => console.error("Live data load failed:", err));

        document.getElementById(`${sensor}-total-loading`).style.display = 'block';
        document.getElementById(`${sensor}-total-container`).style.display = 'none';
        fetch(`/decimated_data/${sensor}`)
            .then(r => r.json())
            .then(data => {
                charts[`${sensor}-total`] = initDecimatedChart(`${sensor}-total-chart`, data, sensor);
                document.getElementById(`${sensor}-total-loading`).style.display = 'none';
                document.getElementById(`${sensor}-total-container`).style.display = 'block';
            })
            .catch(err => console.error("Total data load failed:", err));
    }

    function updateLive(sensor) {
        fetch(`/last_data/${sensor}`)
            .then(r => r.json())
            .then(newData => {
                if (newData && newData.timestamp) {
                    const chart = charts[`${sensor}-live`];
                    if (!chart) return;
                    const params = sensors[sensor].params;
                    chart.data.datasets.forEach((ds, i) => {
                        ds.data.push({ x: newData.timestamp, y: newData[params[i]] || null });
                    });
                    chart.update('quiet');
                }
            })
            .catch(err => console.error("Live update failed:", err));
    }

    // Initial load + periodic live updates
    Object.keys(sensors).forEach(loadMainData);
    setInterval(() => Object.keys(sensors).forEach(updateLive), 10000);

    // ─────────────────────────────────────────────────────────────
    // 3. DETAILED SENSOR TAB - INPUT / FETCHING
    // ─────────────────────────────────────────────────────────────


    function loadCustomRangeData(sensor) {
        const startDate = document.getElementById(`${sensor}-start-date`).value;
        const startTime = document.getElementById(`${sensor}-start-time`).value || '00:00';
        const endDate   = document.getElementById(`${sensor}-end-date`).value;
        const endTime   = document.getElementById(`${sensor}-end-time`).value || '23:59';

        if (!startDate || !endDate) {
            alert("Please select both start and end dates");
            return;
        }

        const startStr = `${startDate} ${startTime}:00`;
        const endStr   = `${endDate} ${endTime}:59`;

        const startTs = new Date(startStr).getTime();
        const endTs   = new Date(endStr).getTime();

        const fullData = fullSensorData[sensor];

        if (!fullData || fullData.length === 0) {
            document.getElementById(`${sensor}-detailed-loading`).innerHTML =
                '<div class="loading-text text-warning">No full data loaded yet</div>';
            return;
        }

        // Filter locally
        const filtered = fullData.filter(d => {
            const ts = new Date(d.timestamp).getTime();
            return ts >= startTs && ts <= endTs;
        });

        const loading = document.getElementById(`${sensor}-detailed-loading`);
        loading.style.display = 'block';

        if (filtered.length === 0) {
            // Warning + show full instead
            alert("No data in selected range — showing full available dataset instead");
            processAndDisplayDetailedData(sensor, fullData);
        } else {
            processAndDisplayDetailedData(sensor, filtered);
        }

        loading.style.display = 'none';
    }

    function resetToLast24h(sensor) {
        
        const today = new Date().toISOString().split('T')[0];
        document.getElementById(`${sensor}-start-date`).value = today;
        document.getElementById(`${sensor}-start-time`).value = '00:00';
        document.getElementById(`${sensor}-end-date`).value = today;
        document.getElementById(`${sensor}-end-time`).value = '23:59';
        loadCustomRangeData(sensor);
    }

    function resetToLast2h(sensor) {
        // Show loading feedback
        const loading = document.getElementById(`${sensor}-detailed-loading`);
        if (loading) {
            loading.style.display = 'block';
            loading.innerHTML = '<div class="spinner"></div><div class="loading-text">Loading last 2 hours...</div>';
        }

        // Fetch the real last 2 hours directly from backend (same as Main tab uses)
        fetch(`/last_2h_data/${sensor}`)
            .then(r => {
                if (!r.ok) throw new Error("Failed to fetch last 2h data");
                return r.json();
            })
            .then(data => {
                if (data && data.length > 0) {
                    // Set date/time inputs based on actual fetched range
                    const first = new Date(data[0].timestamp);
                    const last  = new Date(data[data.length-1].timestamp);

                    document.getElementById(`${sensor}-start-date`).value = first.toISOString().split('T')[0];
                    document.getElementById(`${sensor}-start-time`).value = first.toTimeString().slice(0,5);
                    
                    document.getElementById(`${sensor}-end-date`).value   = last.toISOString().split('T')[0];
                    document.getElementById(`${sensor}-end-time`).value   = last.toTimeString().slice(0,5);

                    // Display this data directly (no filtering needed)
                    processAndDisplayDetailedData(sensor, data);
                } else {
                    alert("No data in the last 2 hours yet.");
                    loading.style.display = 'none';
                }
            })
            .catch(err => {
                console.error("Last 2h fetch failed:", err);
                alert("Failed to load last 2 hours. Showing full data instead.");
                if (fullSensorData[sensor]) {
                    processAndDisplayDetailedData(sensor, fullSensorData[sensor]);
                }
                loading.style.display = 'none';
            });
    }

    function resetToFullData(sensor) {
        const fullData = fullSensorData[sensor];
        
        if (!fullData || fullData.length === 0) {
            alert("Full data not loaded yet — please wait a moment.");
            return;
        }

        // Show loading spinner briefly
        const loading = document.getElementById(`${sensor}-detailed-loading`);
        loading.style.display = 'block';

        // Directly show the full dataset (exactly like the fallback does)
        processAndDisplayDetailedData(sensor, fullData);

        loading.style.display = 'none';
    }

    // New function: Load full range info, prefill dates, then load full data
    async function initializeSensorTab(sensor) {
            const loading = document.getElementById(`${sensor}-detailed-loading`);
            loading.innerHTML = '<div class="spinner"></div><div class="loading-text">Loading full range...</div>';

            try {
                const res = await fetch(`/sensor_range/${sensor}`);
                if (!res.ok) throw new Error("Range fetch failed");

                const info = await res.json();

                if (!info.start || !info.end) {
                    loading.innerHTML = '<div class="loading-text text-warning">No data available</div>';
                    return;
                }

                // Prefill date/time inputs with actual first/last timestamp
                const startDt = new Date(info.start);
                const endDt   = new Date(info.end);

                document.getElementById(`${sensor}-start-date`).value = startDt.toISOString().split('T')[0];
                document.getElementById(`${sensor}-start-time`).value = startDt.toTimeString().slice(0, 5);
                document.getElementById(`${sensor}-end-date`).value   = endDt.toISOString().split('T')[0];
                document.getElementById(`${sensor}-end-time`).value   = endDt.toTimeString().slice(0, 5);

                // Now load the full range
                loadCustomRangeData(sensor);
            } catch (err) {
                console.error("Initialize tab error:", err);
                loading.innerHTML = '<div class="loading-text text-danger">Failed to load range</div>';
            }
        }
    

    // ─────────────────────────────────────────────────────────────
    // 4. DETAILED SENSOR TAB - PROCESSING & DISPLAY (OUTPUT)
    // ─────────────────────────────────────────────────────────────

    function processAndDisplayDetailedData(sensor, data) {
        const loading = document.getElementById(`${sensor}-detailed-loading`);
        const container = document.getElementById(`${sensor}-detailed-container`);

        if (!data || data.length === 0) {
            loading.innerHTML = '<div class="loading-text text-warning">No data in selected range</div>';
            return;
        }
        const metric = document.getElementById(`${sensor}-metric`).value;
        const color = sensors[sensor].colors[sensors[sensor].params.indexOf(metric)] || '#FF8C00';
        const mode = document.getElementById(`${sensor}-missing-mode`)?.value || 'interpolate';

       
        // Fix dropdown labels for BNO085 (change text to AccX/Y/Z, keep value for chart)
        if (sensor.toUpperCase().includes('BNO085')) {
            const labelMap = {
                'linear_accel_x': 'AccX',
                'linear_accel_y': 'AccY',
                'linear_accel_z': 'AccZ'
            };
            const select = document.getElementById(`${sensor}-metric`);
            if (select) {
                Array.from(select.options).forEach(option => {
                    if (labelMap[option.value]) {
                        option.text = labelMap[option.value];
                    }
                });
            }
        }

        let chartDataPoints = data.map(d => ({
            x: d.timestamp,
            y: d[metric] !== undefined && d[metric] !== null ? d[metric] : null
        }));

        let chartType = 'line';
        let tension = 0.3;
        let spanGaps = true;
        let pointRadius = 2;
        let borderWidth = 2;
        let stepped = false;

        if (mode === 'clip0') {
            // Insert one 0 point after each real point to force drop (minimal extra points)
            const enhanced = [];
            for (let i = 0; i < chartDataPoints.length; i++) {
                enhanced.push(chartDataPoints[i]);
                // If next point exists and there's a gap, insert 0 just before it
                if (i < chartDataPoints.length - 1) {
                    const currTs = new Date(chartDataPoints[i].x).getTime();
                    const nextTs = new Date(chartDataPoints[i+1].x).getTime();
                    if (nextTs - currTs > 60000) {  // gap > 1 min
                        const midTs = new Date((currTs + nextTs) / 2).toISOString();
                        enhanced.push({ x: midTs, y: 0 });  // drop to zero in middle of gap
                    }
                }
            }
            chartDataPoints = enhanced;

            tension = 0;
            spanGaps = true;
            stepped = true;  // ← This creates flat plateaus + sharp vertical drops to zero
        } else if (mode === 'discrete') {
            chartType = 'bar';
            tension = 0;
            spanGaps = false;
            pointRadius = 0;
            borderWidth = 3;
        }

        if (charts[`${sensor}-detailed`]) {
            charts[`${sensor}-detailed`].destroy();
        }

        const chart = new Chart(document.getElementById(`${sensor}-detailed-chart`), {
            type: chartType,
            data: {
                datasets: [{
                    label: metric,
                    data: chartDataPoints,
                    borderColor: color,
                    backgroundColor: mode === 'discrete' ? color + '80' : color + '40',
                    tension: tension,
                    spanGaps: spanGaps,
                    pointRadius: pointRadius,
                    borderWidth: borderWidth,
                    fill: false,
                    stepped: stepped  // ← Key for clip-to-zero: makes horizontal flats + vertical drops
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { labels: { color: 'white' } },
                    zoom: {
                        zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'x' },
                        pan: { enabled: true, mode: 'x' }
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: { parser: 'yyyy-MM-dd HH:mm:ss.SSSSSS' },
                        ticks: { color: 'white' },
                        grid: { color: 'rgba(255,255,255,0.2)' }
                    },
                    y: {
                        min: mode === 'clip0' ? 0 : undefined,          // Force Y to include 0
                        suggestedMin: mode === 'clip0' ? 0 : undefined, // Extra safety
                        ticks: { color: 'white' },
                        grid: { color: 'rgba(255,255,255,0.2)' }
                    }
                }
            }
        });

        charts[`${sensor}-detailed`] = chart;

        // Auto-scale
        if (data.length > 0) {
            const times = data.map(d => new Date(d.timestamp).getTime());
            const minT = Math.min(...times);
            const maxT = Math.max(...times);
            const padding = (maxT - minT) * 0.03 || 3600000;

            chart.options.scales.x.min = new Date(minT - padding);
            chart.options.scales.x.max = new Date(maxT + padding);
            chart.update();
        }


        // Special handling for BNO085: keep only linear accel + rename to acc_x/y/z
        if (sensor.toUpperCase().includes('BNO085')) {
                const labelMap = {
                    'linear_accel_x': 'AccX',
                    'linear_accel_y': 'AccY',
                    'linear_accel_z': 'AccZ'
                };
                chart.data.datasets[0].label = labelMap[metric] || metric;
                chart.update();
            }

        
        loading.style.display = 'none';
        container.style.display = 'block';
    }
        

    function densifyWithZeros(data, metric, startTs, endTs, intervalMs = 60000) {  // 1 min default
        if (data.length === 0) return [];

        const result = [];
        let currentTs = startTs;

        // Sort data by time just in case
        const sorted = [...data].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        let dataIndex = 0;

        while (currentTs <= endTs) {
            const currentDate = new Date(currentTs);
            const nextDataTs = dataIndex < sorted.length ? new Date(sorted[dataIndex].timestamp).getTime() : Infinity;

            if (Math.abs(currentTs - nextDataTs) < intervalMs / 2) {
                // Close enough → use real value
                result.push({
                    x: sorted[dataIndex].timestamp,
                    y: sorted[dataIndex][metric] ?? 0
                });
                dataIndex++;
            } else {
                // Gap → force 0
                result.push({
                    x: currentDate.toISOString(),
                    y: 0
                });
            }

            currentTs += intervalMs;
        }

        return result;
    }


    async function loadAndStoreFullData(sensor) {
    const loading = document.getElementById(`${sensor}-detailed-loading`);
    loading.innerHTML = '<div class="spinner"></div><div class="loading-text">Loading full history...</div>';

    try {
        const r = await fetch(`/decimated_data/${sensor}`);
        if (!r.ok) throw new Error("Failed to load full data");

        const data = await r.json();
        console.log("Full data length:", data.length);
        console.log("First entry:", data[0]);
        console.log("Last entry:", data[data.length-1]);
        if (!data || data.length === 0) {
            loading.innerHTML = '<div class="loading-text text-warning">No data available for this sensor</div>';
            return null;
        }

        // Store full data
        fullSensorData[sensor] = data;

        // Extract real first/last timestamp for prefill
        const times = data.map(d => new Date(d.timestamp).getTime());
        const minTime = new Date(Math.min(...times));
        const maxTime = new Date(Math.max(...times));

        // Prefill inputs
        document.getElementById(`${sensor}-start-date`).value = minTime.toISOString().split('T')[0];
        document.getElementById(`${sensor}-start-time`).value = minTime.toTimeString().slice(0,5);
        document.getElementById(`${sensor}-end-date`).value   = maxTime.toISOString().split('T')[0];
        document.getElementById(`${sensor}-end-time`).value   = maxTime.toTimeString().slice(0,5);

        // Display full data
        processAndDisplayDetailedData(sensor, data);

        return data;
    } catch (err) {
        console.error("Full data load error:", err);
        loading.innerHTML = '<div class="loading-text text-danger">Failed to load full history</div>';
        return null;
    }
}

    // ─────────────────────────────────────────────────────────────
    // 5. DOWNLOAD FUNCTION
    // ─────────────────────────────────────────────────────────────

    function downloadInputRange(sensor) {
        const startDate = document.getElementById(`${sensor}-start-date`).value;
        const startTime = document.getElementById(`${sensor}-start-time`).value || '00:00';
        const endDate   = document.getElementById(`${sensor}-end-date`).value;
        const endTime   = document.getElementById(`${sensor}-end-time`).value || '23:59';

        if (!startDate || !endDate) {
            alert("Please set start and end dates first");
            return;
        }

        // Format exactly as backend expects (no seconds if not needed, but include if you have them)
        const start = `${startDate} ${startTime}:00`;
        const end   = `${endDate} ${endTime}:59`;

        // Optional: Read missing mode (if backend supports it now or later)
        // const missingMode = document.getElementById(`${sensor}-missing-mode`)?.value || 'na';

        const url = `/download_range/${sensor}?start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}`;

        // Optional missing param if your backend already handles it
        // const url = `/download_range/${sensor}?start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}&missing=${missingMode}`;

        window.location.href = url;
    }
    // ─────────────────────────────────────────────────────────────
    // EVENT LISTENERS & INITIALIZATION
    // ─────────────────────────────────────────────────────────────

    // Auto-load detailed chart on first tab open
    // document.getElementById('myTab').addEventListener('shown.bs.tab', e => {
    //     const target = e.target.getAttribute('data-bs-target').substring(1);
    //     if (target !== 'main' && sensors[target] && !charts[`${target}-detailed`]) {
    //         resetToLast24h(target);
    //     }
    // });

    document.getElementById('myTab').addEventListener('shown.bs.tab', e => {
        const target = e.target.getAttribute('data-bs-target').substring(1);
        if (target !== 'main' && sensors[target] && !charts[`${target}-detailed`]) {
            loadAndStoreFullData(target);  // ← New: loads full + prefills + displays
        }
    });
    
    // Reload chart when metric changes
    document.querySelectorAll('[id$="-metric"]').forEach(select => {
        select.addEventListener('change', function() {
            const sensor = this.id.replace('-metric', '');
            loadCustomRangeData(sensor);
        });
    });

    document.querySelectorAll('[id$="-missing-mode"]').forEach(sel => {
        sel.addEventListener('change', function() {
            const sensor = this.id.replace('-missing-mode', '');
            if (fullSensorData[sensor]) {
                processAndDisplayDetailedData(sensor, fullSensorData[sensor]);
            }
        });
    });

</script>

</body>
</html>